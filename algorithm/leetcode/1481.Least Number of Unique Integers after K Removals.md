# 문제

[Least Number of Unique Integers after K Removals](https://leetcode.com/problems/least-number-of-unique-integers-after-k-removals/)

# 생각해보기

배열을 오름차순으로 정렬한다음,

배열의 숫자와 숫자의 개수를 mapping시킨다

k의 개수만큼 map의 요소를 삭제한다.

# 해결방법

위의 방법으로 풀어보다 [k의 개수만큼 map의 요소를 삭제한다.]에서 막혀 풀이를 참고했다.

하지만 오답이었다!

# 코드

```
/**
 * @param {number[]} arr
 * @param {number} k
 * @return {number}
 */
var findLeastNumOfUniqueInts = function(arr, k) {
    arr.sort((a, b) => a - b);

    const map = new Map();
    for(num of arr) {
        map.has(num) ?  map.set(num, map.get(num) + 1) : map.set(num, 1);
    }
    // 제일 작은 값부터 뺀다
    let count = 0;
    for (let [num, freq] of map) {
        if(k >= freq) {
            k -= freq;
            map.delete(num);
        } else {
            break;
        }
    }
    return map.size;
};
```

# 다른 풀이

```
 const freqMap = new Map();
    arr.forEach(num => {
        freqMap.set(num, (freqMap.get(num) || 0) + 1);
    });

    const sortedFreq = Array.from(freqMap.entries()).sort((a, b) => a[1] - b[1]);

    for (let [num, freq] of sortedFreq) {
        if (k >= freq) {
            k -= freq;
            freqMap.delete(num);
        } else {
            break;
        }
    }
    return freqMap.size;
```

# 참고
