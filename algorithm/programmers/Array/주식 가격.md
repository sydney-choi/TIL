# 문제

[주식 가격](https://school.programmers.co.kr/learn/courses/30/lessons/42584?language=javascript)

# 어떤 알고리즘을 적용하려고 했는지, 그 근거를 서술해주세요.

- [ ] 분기, 반복 사용한 절차 문제
- [ ] 자료를 어떠한 자료구조에 담아두어야 효율적인 문제
- [ ] 빠른 성능을 위해 이미 연구된 알고리즘을 사용하는 문제
- [x] 특정 사고방식으로 접근해야 하는 문제

문제를 보자마자 스택을 떠올리기 쉽지 않았다.

-> 어떻게 하면 불필요한 연산을 줄일 수 있을까를 고민해본다.

prices의 길이가 최대 10만이므로 o(n)의 알고리즘이 필요하다.

주어진 배열이 [1, 2, 3, 2, 3] 인 경우,

3->2애서 주식 가격이 처음 떨어졌으므로 3은 길이가 1이다.(1초가 지나 주식의 가격이 2가 된 것으로 보고 계산은 0초가 아닌 1초로 계산)

그리고 그 앞의 가격중 2보다 가격이 높은 원소의 길이는 이 때 모두 확정할 수 있다.

즉, 주식 가격이 처음 떨어진 주식의 뒤가 아니라 앞의 주식 가격을 보며 길이를 구하고 있다.

정리해보면 다음과 같다.

1. 현재 주식보다 이전 주식의 가격이 높으면 이전 주식의 길이를 확정한다.(3->2에서 3의 길이 확정)
2. 이전 주식들을 하나씩 보고(3이전) 현재 주식 가격(2)보다 큰 주식 가격이 있다면 그 주식의 길이를 확정한다.
3. **길이를 확정한 주식은 이후 계산에서 제외한다.**

최근 주식부터 그 이전으로 거슬러 올라가며 비교하므로 스택을 사용하면 된다.

# 어떻게 이 알고리즘을 코드로 만들 수 있을까요?

1. prices의 요소를 순회하면서, 스택에 있는 값과 비교하여 현재 값보다 더 큰 경우(가격이 떨어진 경우) 이전 값의 기간을 계산
2. 스택에 남아있는 가격들은 가격이 떨어지지 않은 경우이므로 한번에 계산

# 코드

# 풀지 못하거나 참고할만한 좋은 풀이

```js
function solution(prices) {
  const n = prices.length;
  const stack = [0];
  const answer = new Array(n).fill(0); // 가격이 떨어지지 않은 기간을 저장할 배열

  // stack을 사용해 이전 가격과 현재 가격을 비교
  const stack = [0];
  for (let i = 1; i < n; i++) {
    while (stack.length > 0 && prices[i] < prices[stack[stack.length - 1]]) {
      // 가격이 떨어졌으므로 이전 가격을 계산
      const j = stack.pop();
      answer[j] = i - j;
    }
    stack.push(i);
  }

  // 가격이 떨어지지 않은 경우
  while (stack.length > 0) {
    const j = stack.pop();
    answer[j] = n - 1 - j;
  }

  return answer;
}
```

# 참고
