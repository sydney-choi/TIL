# 문제

n개의 양의 정수로 이루어진 리스트 arr와 정수 target이 주어졌을 때 이 중에서 합이 target인 두 수가 arr에 있는지 찾고, 있으면 true, 없으면 false를 반환하는 solution()함수를 작성하세요.

## 제약조건

- n은 2이상 10,000 이하의 자연수입니다.
- arr의 각 원소는 1 이상 10,000 이하의 자연수입니다.
- arr의 원소 중 중복되는 원소는 없습니다.
- target은 1 이상 20,000이하의 자연수입니다.

## 입출력 예

| arr             | target | return |
| --------------- | ------ | ------ |
| [1, 2, 3, 4, 8] | 6      | True   |
| [2, 3, 5, 9]    | 10     | False  |

# 어떤 알고리즘을 적용하려고 했는지, 그 근거를 서술해주세요.

- [ ] 분기, 반복 사용한 절차 문제
- [x] 자료를 어떠한 자료구조에 담아두어야 효율적인 문제
- [ ] 빠른 성능을 위해 이미 연구된 알고리즘을 사용하는 문제
- [x] 특정 사고방식으로 접근해야 하는 문제

처음 생각했던건 arr을 순회하면서, target에세 arr요소를 뺀 값이 arr에 있는지 탐색하는 것이었다.

접근 방법은 맞지만, `어떻게 접근하느냐`에 따라 시간복잡도가 달라질 수 있다.

처음 생각해본 로직은 includes를 사용하는 것이었지만, 시간복잡도가 O(N^2)므로 다른 방법을 생각해야 했다.

책에서는 해시 테이블을 생성하여, O(N + K)로 풀었다.

# 어떻게 이 알고리즘을 코드로 만들 수 있을까요?

문제에서 두 수는 모두 arr의 원소라고 했으므로 원소의 유무를 표시할 수 있는 해시 테이블을 활용하면 O(1)안에 찾을 수 있다. 그림으로 표현하면 아래와 같다.

<img src="./두 개의 수로 특정 값 만들기.png" width="300px" height="250px">

왼쪽이 arr, 오른쪽이 arr의 원소 유무를 표현한 해시 테이블이다. 해시 테이블의 크기는 arr의 원소 중 가장 큰 원소의 값 8과 같다.

각 원소에 대해 해시테이블[target - 원소]가 1이면 합을 통해 target을 만들 수 있는 두 수가 arr에 있다고 할 수 있다.

# 맨 처음 생각한 코드

```js
function solution(arr, target) {
  for (let num of arr) {
    const complement = target - num;
    if (arr.includes(complement) && complement !== num) return true;
    else continue;
  }
  return false;
}
```

# 풀지 못하거나 참고할만한 좋은 풀이

해시 테이블을 사용한 코드

```js
function countSort(arr, k) {
  // 해시 테이블 생성 및 초기화
  const hashtable = new Array(k + 1).fill(0);
  for (const num of arr) {
    // 현재 원소의 값이 k이하인 때에만 처리
    if (num <= k) {
      //현재 원소의 값을 인덱스로 해 해당 인덱스의 해시 테이블 값을 1로 설정
      hashtable[num] = 1;
    }
  }
  return hashtable;
}
function solution(arr, target) {
  const hashtable = countSort(arr, target);
  for (const num of arr) {
    const complement = target - num;
    //target에서 현재 원소를 뺀 값이 해시 테이블에 있는지 확인
    // 주의) target에서 현재 원소를 뺀 값이 현재 원소와 달라야 함
    if (
      complement !== num &&
      complement >= 0 &&
      complement <= target &&
      hashtable[complement] === 1
    ) {
      return true;
    }
  }
  return false;
}
```

자료구조 Set을 사용한 코드

Set은 해시 테이블 기반이므로 평균적으로 O(1)시간이 소요된다.

```js
function solution(arr, target) {
  const numSet = new Set(arr); // arr의 모든 요소를 Set에 저장

  for (let num of arr) {
    const complement = target - num;
    if (numSet.has(complement) && complement !== num) {
      return true;
    }
  }
  return false;
}
```
