# 문제

[모의고사](https://school.programmers.co.kr/learn/courses/30/lessons/42840?language=javascript)

# 어떤 알고리즘을 적용하려고 했는지, 그 근거를 서술해주세요.

- [x] 분기, 반복 사용한 절차 문제
- [ ] 자료를 어떠한 자료구조에 담아두어야 효율적인 문제
- [ ] 빠른 성능을 위해 이미 연구된 알고리즘을 사용하는 문제
- [x] 특정 사고방식으로 접근해야 하는 문제

**왜 풀지 못했을까? 생각해보기**

정답 패턴의 길이 > 수포자 패턴일 경우 어떻게 수포자 패턴을 처음부터 비교할 수 있었을지 생각이 나지 않았다.

문제를 풀다가 너무 졸려서 한숨 자고 일어나 무의식적으로 답안을 보게된 것 같다.

**action plan**

나머지 연산자를 사용해 길이가 다른 배열을 조작할 수 있다.

충분히 생각하는 습관이 아직 잡히지 않은 것 같다.

# 어떻게 이 알고리즘을 코드로 만들 수 있을까요?

1. 수포자들의 패턴을 미리 배열에 저장한다. (이렇게 특정 패턴이 있으면 배열에 미리 담아도 OK)
2. 수포자들의 패턴과 답안을 비교해서 일치하는지 확인할 배열을 선언한다.
3. 일치하는지 확인한다.
4. 가장 높은 점수를 저장한다.
5. 가장 높은 점수를 받은 수포자들의 번호를 찾아 배열에 담는다.

# 코드

# 풀지 못하거나 참고할만한 좋은 풀이

```js
function solution(answers) {
  var scores = [0, 0, 0];
  const patterns = [
    [1, 2, 3, 4, 5],
    [2, 1, 2, 3, 2, 4, 2, 5],
    [3, 3, 1, 1, 2, 2, 4, 4, 5, 5],
  ];

  for (const [i, answer] of answers.entries()) {
    for (const [j, pattern] of patterns.entries()) {
      // 정답 패턴의 길이가 수포자의 답안 길이보다 긴 경우
      if (answer === pattern[i % pattern.length]) {
        scores[j] += 1;
      }
    }
  }

  const maxScore = Math.max(...scores);
  const highestScores = [];

  for (let i = 0; i < scores.length; i++) {
    if (scores[i] === maxScore) {
      highestScores.push(i + 1);
    }
  }

  return highestScores;
}
```

# 참고
